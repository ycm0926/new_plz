---

title: "Ch8 Dynamic Programing 8-1"
categories: Algorithm
tag: [Python, Algorithm, 이것이 코딩 테스트다]
toc: true
toc_sticky: true
author_profile: true
sidebar:
    nav: "docs"

---

# 📚 동적 프로그레밍 (Dynamic Programing) 알고리즘

**동적 프로그래밍 (Dynamic Programing)** 이란 <span style="background-color:#8B03FF">메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법.</span>
* 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 함.
* 다이나믹 프로그래밍의 구현은 일반적으로 <span style="background-color:#8B03FF">두 가지 방식(탑다운과 보텀업)으로 구성.</span>
* 다이나믹 프로그래밍은 <span style="background-color:#8B03FF">동적 계획법</span>이라고도 부름.
* DP는 다음의 조건을 만족할 때 사용할 수 있다.
  1. 최적 부분 구조 (Optimal Substructure)
       * 큰 문제를 작은 문제로 난루 수 있으며 작은 문제의 답은 큰 문제를 해결할 수 있다.
  2. 중복되는 부분 문제 (Overlapping Subproblem)
       * 동일한 작은 문제를 반복적으로 해결해야 한다.

> 동적(Dynamic)이란
> * 자료구조에서 동적 할당(Dynamic Allocation)은 '프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법'을 의미합니다
> * 반면에 다이나믹 프로그래밍에서 '다이나믹'은 별다른 의미 없이 사용된 단어이다


다이나믹 프로그래밍으로 해결할 수 있는 대표적인 예시로 **피보나치 수열**이 있다.

## 피보나치 수열
* 피보나치 수열이란 이전 두항의 합을 현재의 항으로 설정하는 특징이 있는 수열이다. 피보나치 수열은 다음과 같은 형태로 끝없이 이어진다.
* 점화식을 사용해 피보나치 수열을 간결하게 표현이 가능하다.
* 피보나치 수열의 점화식은 다음과 같다.
  * a(n) = a(n-1) + a(n-2)
    * n 번째 피보나치 수 = (n-1)번째 피보나치 수 + (n-2)번째 피보나치 수
  * a(1) = 1, a(2) = 2
    * 단, 1번째 피보나치 수 = 1, 2번째 피보나치 수 = 1

![피보나치](/assets/images/algorithm/ch8/ch-08-피보나치.png)

* 프로그래밍 에서는 이러한 수열을 **배열**이나 **리스트**로 표현할 수 있다.
* 수학적 점화식을 프로그래밍으로 표현하려면 재귀 함수를 사용하면 간단하다.

```python
# 피보나치 함수를 단순 재귀 함수로 표현
def fibo(x):
	if x==1 or x==2:
    	return 1
    return fibo(x-1) + fibo(x-2)
print(fibo(4))
```
## 피보나치 수열의 시간복잡도 분석

![피보나치](/assets/images/algorithm/ch8/ch-08-피보나치2.png)


* f(n)에서 n이 커질수록 호출 수가 많아지므로 좋지않은 코드이다.
* 피보나치 수열의 시간 복잡도는 다음과 같음.
  * 세타 표기법: 𝜃(1.618⋯ᴺ)
  * 빅오 표기법: O(2ᴺ)
* 빅오 표기법을 기준으로 f(30)을 계산하기 위해 약 10억가량의 연산을 수행해야 함.

---

## 피보나치 수열 효율적인 해법: DP

* 다음 조건을 만족할 때 DP를 사용할 수 있다.
  1. 큰 문제를 작은 문제로 나눌 수 있다.
  2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
* 메모제이션 기법을 사용해서 해결이 가능하다.
  * 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류.
  * 한 번 구한 결과를 메모리 공간에 메모하는 기법.
    * 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법.
    * 값을 기록해 놓는다는 점에서 **캐싱(Cashing)**이라고도 한다. 
  * 구현은 단순하게 한번 구한 정보를 리스트에 저장하는 것이다.

## 탑다운 VS 보텀업 
* 탑다운(메모제이션) 방식은 **하향식**이라고도 하며 보텀업 방식은 **상향식**이라고도 한다.
* DP의 전형적인 형태는 **보텀업** 방식이다.
  * 결과 저장용 리스트는 **DP 테이블**이라고 부른다.
* 메모제이션은 **이전에 계산된 결과를 일시적으로 기록해 놓은 넓은 개념을 의미한다.**
  * 따라서 메모제이션은 DP에 국한된 개념이 아니다.
  * 한 번 계산된 결과를 담아 놓기만 하고 DP를 위해 활용하지 않을 수도 있다.

```python
# 피보나치 수열: 탑다운 DP 소스코드
# 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
d = [0] * 100
# 피보나치 함수(Fibonacci Function)를 재귀함수로 구현(탑다운 DP)
def fibo(x):
    # 종료 조건(1 혹은 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]
print(fibo(99))
>>> 218922995834555169026
```

```python
# 피보나치 수열: 보텀업 DP 소스코드
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100
# 첫번째 피보나치 수와 두번째 피보나치 수는 1
d[1] = 1
d[2] = 2
n = 99
# 피보나치 함수(Fibonacci Function) 반복문으로 구현(보텀업 DP)
for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]
print(d[n])
>>> 218922995834555169026
```

## 피보나치 수열: 메모제이션 동작 분석

이미 계산된 결과를 메모리에 저장하여 다음과 같이 색칠된 노드만 처리할 것을 기대 할 수 있다.

![피보나치](/assets/images/algorithm/ch8/ch-08-피보나치3.png)


실제로 호출되는 함수는 색칠된 함수만 호출된다.

![피보나치](/assets/images/algorithm/ch8/ch-08-피보나치4.png)

* 메모이제이션을 이용하는 경우 시간 복잡도는 O(N)

### 피보나치 소스코드(탑다운)

* 재귀 함수를 이용하여 큰 문제를 해결하기 위해 작은 문제를 호출하는 경우

```python
d = [0] * 100
def fibo(x):
    print('f(' + str(x) + ')', end=' ')
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]
fibo(6)
>>>> f(6) f(5) f(4) f(3) f(2) f(1) f(2) f(3) f(4)
```
### 피보나치 소스코드(보텀업)

* 동일한 원리를 적용하되 단순히 반복문을 이용하여 작은 문제부터 문제를 해결

```python
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100
# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 1
n = 99
# 피보나치 함수 반복문으로 구현(bottom-up)
for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]
print(d[n])
```

## 다이나믹 프로그래밍 VS 분할 정복
* 이러한 큰 문제를 작게 나누는 방법은 퀵 정렬에서도 소개된 적이 있다.
  * 퀵 정렬은 정렬을 수행할 때 정렬할 리스트를 분할하여 전체적으로 정렬이 될 수 있도록 한다. 이는 **분할 정복** 알고리즘으로 분류된다.
[->퀵정렬 분할정복](https://ycm0926.github.io/algorithm/Ch6-Sorting-1/)

* DP와 분할 정복은 모두 **최적 부분 구조**를 가질 때 사용할 수 있다.
  * 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황
* DP와 분할 정복의 차이점은 **부분 문제의 중복**이다.
  * DP 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복된다.
  * 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않는다.


## 다이나믹 프로그래밍 문제에 접근하는 방법
* 가장 먼저 그리디, 구현 완전 탐색 등의 아이디어로 가능한지 검토할 수 있다.
  * 다른 알고리즘으로 풀이 방법이 떠오르지 않으면 DP를 고려한다.
* 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 즉 메모제이션을 적용할 수 있으면 코드를 개선하는 방법을 사용할 수 있다.
* 가능하다면 재귀 함수를 이용하는 탑다운 방식 보다는 반복을 이용한 보텀업 방식으로 구현하는것을 권장한다.
  * 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문.
* **일반적인 코딩 테스트 수준에서는 기본 유형의 DP문제가 출제**되는 경우가 많다.
