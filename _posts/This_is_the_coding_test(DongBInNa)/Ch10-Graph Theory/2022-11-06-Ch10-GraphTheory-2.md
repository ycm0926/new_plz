---

layout: single
title: "Ch10 Graph Theory 10-2"
categories: Algorithm
tag: [Python, Algorithm, 이것이 코딩 테스트다]
toc: true
author_profile: false
sidebar:
    nav: "docs"

---

## ⚡ [문제 1] 팀 결성

* **난이도: 🌕🌕**
* **풀이시간: 20분**
* **시간 제한: 2초**
* **메모리 제한: 128MB**
* **기출: 핵심 유형**


**[문제]**

학교에서 학생들에게 0번부터 N번까지의 번호를 부여했다. 처음에는 모든 학생이 서로 다른 팀으로 구분되어, 총 N+1 개의 팀이 존재한다. 이때 선생님은 "팀 합치기" 연산과 "같은 팀 여부 확인" 연산을 사용할 수 있다.

1. "팀 합치기" 연산은 두 팀을 합치는 연산이다.

2. "같은 팀 여부 확인" 연산은 특정한 두 학생이 같은 팀에 속하는지를 확인하는 연산이다.

선생님이 M개의 연산을 수행할 수 있을 때, "같은 팀 여부 확인" 연산에 대한 연산 결과를 출력하는 프로그램을 작성

**[입력 조건]**

* 첫째 줄에 N,M이 주어진다. M은 입력으로 주어지는 연산의 개수이다. (1 ≤ N,M ≤ 100,000)
* 다음 M개의 줄에는 각각의 연산이 주어진다.
* '팀 합치기' 연산은 0 a b 형태로 주어진다. 이는 a번 학생이 속한 팀과 b번 학생이 속한 팀을 합친다는 의미이다.
* '같은 팀 여부 확인' 연산은 1 a b 형태로 주어진다. 이는 a번 학생과 b번 학생이 같은 팀에 속해 있는지를 확인하는 연산이다.
* a와 b는 N 이하의 양의 정수이다.

**[출력 조건]**

* '같은 팀 여부 확인' 연산에 대해 한 줄에 하나씩 YES 혹은 NO로 결과를 출력한다.

```python  
# 입력 예시
7 8
0 1 3
1 1 7
0 7 6
1 7 1
0 3 7
0 4 2
0 1 1
1 1 1
# 출력 예시
NO
NO
YES
```

**[문제 해설]**

* 전형적인 서로소 집합 알고리즘 문제
* N과 M의 범위가 모두 최대 100,000이기 때문에 경로 압축 방식의 서로소 집합 자료구조를 이용해 시간 복잡도를 개선해야 한다.

```python

# 교재 풀이

# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

n, m = map(int, input().split())
parent = [0] * (n + 1) # 부모 테이블 초기화

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(0, n + 1):
    parent[i] = i

# 각 연산을 하나씩 확인
for i in range(m):
    oper, a, b = map(int, input().split())
    # 합치합(Union) 연산인 경우
    if oper == 0:
        union_parent(parent, a, b)
    # 찾기(Find) 연산인 경우
    elif oper == 1:
        if find_parent(parent, a) == find_parent(parent, b):
            print('YES')
        else:
            print('NO')

```


## ⚡ [문제 2] 도시 분할 계획

* **난이도: 🌕🌕**
* **풀이시간: 40분**
* **시간 제한: 2초**
* **메모리 제한: 256MB**
* **기출: 기초 문제집**


**[문제]**

동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그러다가 평화로운 마을에 가게 되었는데, 그곳에서는 알 수 없는 일이 벌어지고 있었다.

마을은 N개의 집과 그 집들을 연결하는 M개의 길로 이루어져 있다. 길은 어느 방향으로든지 다닐 수 있는 편리한 길이다. 그리고 각 길마다 길을 유지하는데 드는 유지비가 있다.

마을의 이장은 마을을 두 개의 분리된 마을로 분할할 계획을 가지고 있다. 마을이 너무 커서 혼자서는 관리할 수 없기 때문이다. 마을을 분할할 때는 각 분리된 마을 안에 집들이 서로 연결되도록 분할해야 한다. 각 분리된 마을 안에 있는 임의의 두 집 사이에 경로가 항상 존재해야 한다는 뜻이다. 마을에는 집이 하나 이상 있어야 한다.

그렇게 마을의 이장은 계획을 세우다가 마을 안에 길이 너무 많다는 생각을 하게 되었다. 일단 분리된 두 마을 사이에 있는 길들은 필요가 없으므로 없앨 수 있다. 그리고 각 분리된 마을 안에서도 임의의 두 집 사이에 경로가 항상 존재하게 하면서 길을 더 없앨 수 있다. 마을의 이장은 위 조건을 만족하도록 길들을 모두 없애고 나머지 길의 유지비의 합을 최소로 하고 싶다. 이것을 구하는 프로그램을 작성하시오.

**[입력 조건]**

* 첫째 줄에 집의 개수 N, 길의 개수 M이 주어진다. N은 2 이상 100,000 이하인 정수이고, M은 1 이상 1,000,000 이하인 정수이다.
* 그다음 줄부터 M줄에 걸쳐 길의 정보가 A,B,C 3개의 정수로 공백으로 구분되어 주어지는데 A번 집과 B번 집을 연결하는 길의 유지비가 C(1≤C≤1,000)라는 뜻이다.

**[출력 조건]**

* 첫째 줄에 길을 없애고 남은 유지비 합의 최솟값을 출력한다.

```python  
# 입력 예시
3 2 1
1 2 4
1 3 2

# 출력 예시
2 4
```

**[문제 해설]**

* 핵심 아이디어는 전체 그래프에서 2개의 최소 신장 트리 만들어야 한다.
* 크루스칼 알고리즘으로 최소 신장 트리를 찾은 뒤에 최소 신장 트리를 구성하는 간선 중에서 가장 비용이 큰 간선을 제거한다.
  * 최소 신장 트리가 2개의 부분 그래프로 나누어지며, 문제에서 요구하는 최적의 해를 만족한다.
  * 따라서 최소 신장 트리를 찾은 뒤에 가장 큰 간선을 제거하는 코드를 작성하면 된다.

```python
# 교재 풀이

# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# 노드의 개수와 간선(Union 연산)의 개수 입력받기
v, e = map(int, input().split())
parent = [0] * (v + 1) # 부모 테이블 초기화

# 모든 간선을 담을 리스트와, 최종 비용을 담을 변수
edges = []
result = 0

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
    parent[i] = i

# 모든 간선에 대한 정보를 입력받기
for _ in range(e):
    a, b, cost = map(int, input().split())
    # 비용순으로 정렬하기 위해서 튜플의 첫 번째 원소를 비용으로 설정
    edges.append((cost, a, b))

# 간선을 비용순으로 정렬
edges.sort()
last = 0 # 최소 신장 트리에 포함되는 간선 중에서 가장 비용이 큰 간선

# 간선을 하나씩 확인하며
for edge in edges:
    cost, a, b = edge
    # 사이클이 발생하지 않는 경우에만 집합에 포함
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        result += cost
        last = cost

print(result - last)

```


## ⚡ [문제 3] 커리큘럼

* **난이도: 🌕🌕🌕**
* **풀이시간: 50분**
* **시간 제한: 2초**
* **메모리 제한: 128MB**
* **기출: 핵심 유형**


**[문제]**

동빈이는 온라인으로 컴퓨터공학 강의를 듣고 있다. 이때 각 온라인 강의는 선수 강의가 있을 수 있는데, 선수 강의가 있는 강의는 선수 강의를 먼저 들어야만 해당 강의를 들을 수 있다.

예를들어 '알고리즘’ 강의의 선수 강의로 '자료구조'가 존재한다면, ‘자료구조를 들은 이후에 ‘알고리즘' 강의를 들을 수 있다.

총 N개의 강의를 들으려고 한다. 모든 강의는 1번부터 N번까지의 번호를 가진다. 또한 동시에 여러 개의 강의를 들을 수 있다고 가정한다.

예를 들어 N=3일 때, 3번강의의 선수 강의로 1번과 2번강의가 있고, 1번과 2번강의는 선수강의가 없다고 가정하자.

그리고 각 강의에 대하여 강의 시간이 다음과 같다고 가정하자.

1번 강의: 30시간

2번 강의: 20시간

3번 강의: 40시간

![커리큘럼](/assets/images/ch10/ch-10-커리큘럼.png)

이 경우 1번 강의를 수강하기까지의 최소 시간은 30시간, 2번 강의를 수강하기까지의 최소 시간은 20시간, 3번 강의를 수강하기까지의 최소 시간은 70시간이다.

듣고자 하는 N개의 강의 정보가 주어졌을 때, N개의 강의에 대해 수강하기까지 걸리는 최소 시간을 각각 출력하는 프로그램을 작성하시오.

**[입력 조건]**

* 첫째 줄에 듣고자 하는 강의의 수 N(1≤N≤500)이 주어진다.
* 다음 N개의 줄에는 각 강의 시간과 그 강의 시간을 듣기 위해 먼저 들어야 하는 강의들의 번호가 자연수로 주어지며, 각 자연수는 공백으로 구분한다. 이때 강의 시간은 100,000 이하의 자연수이다.
* 각 강의 번호는 1부터 N까지로 구성되며, 각 줄은 -1로 끝난다.

**[출력 조건]**

* N개의 강의에 대해 수강하기까지 걸리는 최소 시간을 한 줄에 하나씩 출력한다.

```python  
# 입력 예시
5
10 -1
10 1 -1
4 1 -1
4 3 1 -1
3 3 -1

# 출력 예시
10
20
14
18
17
```

**[문제 해설]**

* 위상 정렬 알고리즘의 응용문제이다.
  * 각 노드(강의)에 대하여 인접한 노드를 확인할 때, 인접한 노드에 대하여 현재보다 강의 시간이 더 긴 경우를 찾는다면, 더 오랜 시간이 걸리는 경우의 시간 값을 저장하는 방식으로 결과 테이블을 갱신하여 답을 구할 수 있다.
  * 위상 정렬을 수행하면서, 매번 간선 정보를 확인하여 결과 테이블을 갱신한다.
* 소스코드에서는 최종적으로 각 강의를 수강하기까지의 최소 시간을 result리스트(결과테이블)변수에 담도록 하였다.
  * 처음 각 강의 시간은 time 리스트 변수에 담겨져 있는데, 위상 정렬 함수의 초기 부분에서 deepcopy() 함수를 이용하여 time 리스트 변수의 값을 복사하여 result 리스트 변수의 값으로 설정하는 작업 수행한다.
    * 리스트의 경우 단순히 대입 연산을 하면 값이 변경될 때 문제가 발생할 수 있기 때문이다.
  * deepcopy를 안쓰고 time만들 때 하나 더 만들고 값을 넣어줘도 된다.

>📌리스트의 값을 복제해야 할 때는 deepcopy() 함수를 사용하자  
> * 추가로 copy 모듈의 copy() 메소드와의 차이점은 copy() 는 배열의 내부 객체까지 깊은 복사를 해주지 않는 차이점이 있다. (즉, 이중 이상의 배열은 완전한 깊은복사가 이루어지지 않음)
> * 자세한 내용은 -> [파이썬 깊은 복사](https://crackerjacks.tistory.com/14)


```python
from collections import deque
import copy

# 노드의 개수 입력받기
v = int(input())
# 모든 노드에 대한 진입차수는 0으로 초기화
indegree = [0] * (v + 1)
# 각 노드에 연결된 간선 정보를 담기 위한 연결 리스트(그래프) 초기화
graph = [[] for i in range(v + 1)]
# 각 강의 시간을 0으로 초기화
time = [0] * (v + 1)

# 방향 그래프의 모든 간선 정보를 입력받기
for i in range(1, v + 1):
    data = list(map(int, input().split()))
    time[i] = data[0] # 첫 번째 수는 시간 정보를 담고 있음
    for x in data[1:-1]:
        indegree[i] += 1
        graph[x].append(i)

# 위상 정렬 함수
def topology_sort():
    result = copy.deepcopy(time) # 알고리즘 수행 결과를 담을 리스트
    q = deque() # 큐 기능을 위한 deque 라이브러리 사용

    # 처음 시작할 때는 진입차수가 0인 노드를 큐에 삽입
    for i in range(1, v + 1):
        if indegree[i] == 0:
            q.append(i)

    # 큐가 빌 때까지 반복
    while q:
        # 큐에서 원소 꺼내기
        now = q.popleft()
        # 해당 원소와 연결된 노드들의 진입차수에서 1 빼기
        for i in graph[now]:
            # 동시에 여러 강의가 가능하므로 max를 통해 가장 긴 시간이 걸리는 값을 찾는다
            result[i] = max(result[i], result[now] + time[i])
            indegree[i] -= 1
            # 새롭게 진입차수가 0이 되는 노드를 큐에 삽입
            if indegree[i] == 0:
                q.append(i)

    # 위상 정렬을 수행한 결과 출력
    for i in range(1, v + 1):
        print(result[i])

topology_sort()

```
## **🍀** 회고

